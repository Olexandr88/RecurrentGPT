# RecurrentGPT(Patent)

<p align="center"><a href="https://arxiv.org/pdf/2305.13304.pdf">[ðŸ“„ Paper]</a> | <a href="https://www.aiwaves.org/recurrentgpt">[ðŸ¤— Demo - Writing Assistant]</a> | <a href="https://www.aiwaves.org/interactivefiction">[ðŸ¤— Demo - Interactive Fiction]</a> |  <a href="https://www.youtube.com/watch?v=rMnw3ljCibc">[ðŸ“º Video]</a> | <a href="https://discord.gg/aNznfrYPeR">[ðŸ”¥ Discord]</a> </p>
<hr>

## Framework Illustration
<div align=center>
<img src="resources/recurGPT-structure.png" width = "640" alt="struct" align=center />
</div>

> RecurrentGPT replaces the vectorized elements (i.e., cell state, hidden state, input, and output) in a Long-short Term Memory RNN (LSTM) with natural language (i.e., paragraphs of texts), and simulates the recurrence mechanism with prompt engineering. 

> At each timestep t, RecurrentGPT receives a paragraph of text and a brief plan of the next paragraph, which are both generated in step t âˆ’ 1. It then attends to the long-term memory, which contains the summaries of all previously generated paragraphs and can be stored on hard drives, and relevant paragraphs can be retrieved with semantic search.

> RecurrentGPT also maintains a short-term memory that summarizes key information within recent timesteps in natural language and is updated at each time step. RecurrentGPT combines all aforementioned inputs in a prompt and asks the backbone LLM to generate a new paragraph, a short plan for the next paragraph, and updates the long-short term memory by rewriting the short-term memory and appending the summary of the output paragraph to the long-term memory. 

### Example
<div align=center>
<img src="resources/recurGPT-illu.png" width = "640" alt="struct" align=center />
</div>



## Deployment
You can change the configurations given in the `recurrent.sh` script
```yaml
iteration: 10                       #(int) the number of rounds you would like it to roll.
outfile: response.txt               #(str) the output file path.
init_prompt: init_prompt.json       #(str) the path to the prompt used for initialization.
topic: Aliens                       #(str) the topic that you wish your novel is about.
type: science-fiction               #(str) the type of novel you would like to write.

```

Then after specify your `OPENAI_API_KEY` in the `recurrent.sh` file, you can run
```
sh recurrent.sh
```
NOTE: If your local internet is not allowed to access OpenAI's API, you might need to first export your HTTP proxy in the `recurrent.sh` file as well.
```
export http_proxy='your_proxy'
```

## Code Explanation
We break down and explain the major designs of our RecurrentGPT framework.

### Human

The `Human` class simulates a human writer collaborating with an AI to write a novel in Chinese. This class provides a structured interface for managing narrative input, maintaining story memory, and generating structured outputs based on interactive instructions. It is designed to facilitate the writing process by extending AI-generated text, selecting proposed plans, and revising these plans for future paragraphs.

#### Attributes

- **input (dict)**: A dictionary containing narrative elements such as paragraphs, instructions, and output configurations. Key components include:
  - `input_paragraph`: The last paragraph written by the human.
  - `output_paragraph`: The latest paragraph generated by the AI assistant.
  - `output_memory`: A summary of the main storyline, which is maintained and updated as the story progresses.
  - `output_instruction`: Proposed plans for future paragraphs.

- **memory (str)**: This is a string that holds a summary of the main storyline, which can be explicitly provided or derived from `input['output_memory']`. This memory helps maintain continuity and context throughout the writing process.

- **embedder (object)**: An embedding model or related functionality used for processing and understanding text. This could be any model that provides semantic understanding or text embeddings.

- **output (dict)**: A container for storing the outputs generated during the writing process. This includes the extended paragraph, the selected plan, and the revised plan for future writing.

#### Methods

- **`__init__(self, input: Dict[str, str], memory: Optional[str], embedder: Any, model_path:Optional[str])`**:
  Initializes the Human class with the necessary narrative input, optional memory, an embedder for text processing, and a path to the model if API responses are being utilized.

- **`prepare_input(self) -> str`**:
  Prepares and formats the input text by combining various narrative components into a structured prompt for the AI. This method constructs a detailed instruction set for extending the narrative, selecting a plan, and revising a plan based on the current story context.

- **`parse_plan(self, response: str) -> str`**:
  Extracts the selected plan from the AI's response text. This is useful for isolating the plan that has been chosen based on its suitability for the ongoing narrative.

- **`select_plan(self, response_file: Optional[str]) -> str`**:
  Chooses the most suitable plan from a set of proposed plans by generating a structured prompt and obtaining an AI response. This method emphasizes the selection of a plan that aligns well with the narrative context and the storyline.

- **`parse_output(self, text: str) -> Dict[str, str]`**:
  Parses the extended paragraph and revised plan from the AI's response text. This method ensures that the outputs are properly isolated and stored in the class's `output` attribute for further use.

- **`step(self, response_file: Optional[str]) -> None`**:
  Processes one step of the writing interaction by preparing the input, getting the AI's response, and parsing it into structured outputs. This method represents a complete cycle of interaction in the novel-writing process, allowing for continuous story development.

This class effectively models the interaction between a human writer and an AI, helping to streamline the writing process for a novel by automating routine tasks and maintaining a high level of narrative cohesion and creativity.



## Showcases

### Prompt Engineering
<div align=center>
<img src="resources/recurGPT-prompt.png" width = "640" alt="struct" align=center />
</div>

### Iterations

<div align=center>
<img src="resources/recurGPT-case.png" width = "640" alt="struct" align=center />
</div>

> Human writer starts by choosing the topic he/she wants to write and writes a short paragraph describing the background and the outline of the book. Then RECURRENTGPT automatically generates the first paragraphs and provides a few possible options for the writer to continue the story. The writer may select one from them and edit it if needed. He or she can also write a short plan for the next few paragraphs by him/herself if generated plans are all inappropriate, which makes human-AI co-writing process more flexible

## Web demo
You can directly use our online demo at:
https://www.aiwaves.org/recurrentgpt  and https://www.aiwaves.org/interactivefiction

Or you can run it on your local machine by editing the OPENAI_API_KEY and OPENAI_Proxy in utils.py and then run:
```
python gradio_server.py
```

![web-demo](resources/web_demo.png)

## Use customized LLMs for local deployment
Please refer to https://github.com/jackaduma/Recurrent-LLM to use opensource LLMs for local deployment. Many thanks to @jackaduma 

## Citation
```angular2
@misc{zhou2023recurrentgpt,
      title={RecurrentGPT: Interactive Generation of (Arbitrarily) Long Text}, 
      author={Wangchunshu Zhou and Yuchen Eleanor Jiang and Peng Cui and Tiannan Wang and Zhenxin Xiao and Yifan Hou and Ryan Cotterell and Mrinmaya Sachan},
      year={2023},
      eprint={2305.13304},
      archivePrefix={arXiv},
      primaryClass={cs.CL}
}
```
